<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        #graph { width: 100%; height: 600px; }
        #info-box {
            position: absolute; top: 40px; right: 20px;
            width: 250px; padding: 15px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            font-family: Arial, sans-serif;
            z-index: 1000;
        }
        #slider-container {
            position: absolute; top: 20px; left: 20px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="graph"></div>
    <div id="info-box">
        <h2>Reef Information</h2>
        <p id="info-text">Click on a node to see details here.</p>
    </div>
    <div id="slider-container">
        <label for="weight-slider">Weight Filter:</label>
        <input type="range" id="weight-slider" min="0" step="0.01" value="0" />
        <span id="slider-value">0</span>
    </div>

    <script>
        const graphData = {{ graph_data | tojson }};
        const mainNode = graphData.main_node;
        const nodeIndexes = graphData.nodes.index;

        let colors = nodeIndexes.map((_, idx) => idx === mainNode ? '#f4737a' : 'skyblue');

        const layout = {
            title: 'Reef Network Graph',
            showlegend: false,
            hovermode: 'closest',
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            xaxis: { visible: false },
            yaxis: { visible: false },
        };

        // Dynamically set the slider max based on edge weights
        const maxWeight = Math.max(...graphData.edges.weights);
        const slider = document.getElementById('weight-slider');
        const sliderValue = document.getElementById('slider-value');
        slider.max = maxWeight;
        slider.value = 0;
        sliderValue.textContent = slider.value;

        // Debugging: Log initial graph data
        console.log("Initial Graph Data:", graphData);

        function filterGraph(weightThreshold) {
            console.log(`Applying weight threshold: ${weightThreshold}`);
            const filteredEdges = { x: [], y: [], weights: [] };
            const connectedNodes = new Set();

            // Filter edges and track connected nodes
            for (let i = 0; i < graphData.edges.x.length; i += 3) {
                const edgeWeight = graphData.edges.weights[Math.floor(i / 3)];
                console.log(`Edge ${Math.floor(i / 3)}: Weight=${edgeWeight}`);
                if (edgeWeight >= weightThreshold) {
                    console.log(`Including Edge ${Math.floor(i / 3)}`);
                    filteredEdges.x.push(graphData.edges.x[i], graphData.edges.x[i + 1], null);
                    filteredEdges.y.push(graphData.edges.y[i], graphData.edges.y[i + 1], null);
                    filteredEdges.weights.push(edgeWeight);

                    const startNodeIndex = Math.floor(i / 3);
                    const endNodeIndex = Math.floor(i / 3);

                    if (graphData.nodes.index[startNodeIndex]) {
                        connectedNodes.add(graphData.nodes.index[startNodeIndex]);
                    }
                    if (graphData.nodes.index[endNodeIndex]) {
                        connectedNodes.add(graphData.nodes.index[endNodeIndex]);
                    }
                } else {
                    console.log(`Excluding Edge ${Math.floor(i / 3)}`);
                }
            }

            console.log("Connected Nodes:", Array.from(connectedNodes));

            const filteredNodes = { x: [], y: [], name: [], color: [], strata: [] };
            graphData.nodes.index.forEach((node, i) => {
                if (connectedNodes.has(node)) { // Compare node names
                    console.log(`Including Node: ${node}`);
                    filteredNodes.x.push(graphData.nodes.x[i]);
                    filteredNodes.y.push(graphData.nodes.y[i]);
                    filteredNodes.name.push(graphData.nodes.name[i]);
                    filteredNodes.color.push(colors[i]);
                    filteredNodes.strata.push(graphData.nodes.strata[i]);
                } else {
                    console.log(`Excluding Node: ${node}`);
                }
            });

            console.log("Filtered Nodes:", filteredNodes);
            console.log("Filtered Edges:", filteredEdges);

            // Update traces
            const newEdgeTrace = {
                x: filteredEdges.x,
                y: filteredEdges.y,
                line: { width: 2, color: graphData.edges.line_color },
                mode: 'lines',
                hoverinfo: 'none',
            };

            const newNodeTrace = {
                x: filteredNodes.x,
                y: filteredNodes.y,
                mode: 'markers+text',
                marker: {
                    color: filteredNodes.color,
                    size: 50,
                    line: { width: 2 },
                    opacity: 1,
                },
                text: filteredNodes.name,
                textposition: 'middle center',
                hoverinfo: 'text',
            };

            console.log("Edge Trace:", newEdgeTrace);
            console.log("Node Trace:", newNodeTrace);

            // Update the graph
            Plotly.react('graph', [newEdgeTrace, newNodeTrace], layout);
        }

        // Add event listener for the slider
        slider.addEventListener('input', () => {
            const weightThreshold = parseFloat(slider.value);
            console.log(`Current Weight Threshold: ${weightThreshold}`);
            sliderValue.textContent = weightThreshold.toFixed(2);
            filterGraph(weightThreshold);
        });

        // Initial plot
        filterGraph(0);
    </script>
</body>
</html>